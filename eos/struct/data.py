from __future__ import annotations
from datetime import datetime
from typing import TypeVar, Dict, List, Optional
from typing_extensions import NotRequired, TypedDict
from bson import ObjectId
from numpy import ndarray
from configparser import ConfigParser
import re


#  Define TypedDict for type hinting of typed collections: records and episodes


class ObservationSpecs(TypedDict):
    """Observation of the episode."""

    velocity_unit: str  # unit of velocity, default "kph"
    thrust_unit: str  # unit of thrust, default "pct"
    brake_unit: str  # unit of brake, default "pct"


class StateSpecs(TypedDict):
    """Observation of the episode."""

    observation_specs: ObservationSpecs
    unit_number: int
    unit_duration: int
    frequency: int


class ActionSpecs(TypedDict):
    """Action of the episode."""

    action_row_number: int
    action_column_number: int


class PlotDict(TypedDict):
    """Plot of the item specs"""

    character: str
    driver: str
    when: datetime
    tz: NotRequired[str]
    where: str
    state_specs: StateSpecs
    action_specs: ActionSpecs
    reward_specs: Dict[str, str]


class Plot:
    """
    Plot with method to calculate the number of states and actions
    and to compare two plots
    Use composition instead of inheritance to avoid the issue that TypedDict class cannot have customized methods
    proposed by chatgpt
    """

    def __init__(
        self,
        character: str,
        driver: str,
        when: datetime,
        tz: str,
        where: str,
        state_specs: StateSpecs,
        action_specs: ActionSpecs,
        reward_specs: Dict,
        plot_dict: Optional[PlotDict] = None,
    ):
        if plot_dict is None:
            self.plot_dict = {
                'character': character,
                'driver': driver,
                'when': when,
                'tz': tz,
                'where': where,
                'state_specs': state_specs,
                'action_specs': action_specs,
                'reward_specs': reward_specs,
            }
        else:
            self.plot_dict = plot_dict.copy()

    def get_number_of_states(self) -> int:
        """
        get number of states from StateSpecs
        """

        return (
            len(self.plot_dict['state_specs']['observation_specs'])
            * self.plot_dict['state_specs']['unit_number']
            * self.plot_dict['state_specs']['unit_duration']
            * self.plot_dict['state_specs']['frequency']
        )

    def get_number_of_actions(self) -> int:
        """
        get number of actions from ActionSpecs
        """
        return (
            self.plot_dict['action_specs']['action_row_number']
            * self.plot_dict['action_specs']['action_column_number']
        )

    def get_number_of_states_actions(self) -> (int, int):
        """
        get number of states and actions from Plot
        """
        return self.get_number_of_states(), self.get_number_of_actions()

    def are_same_plots(self, plot_to_compare: Plot):
        """
        Compare two plots, return True if they are the same, while ignoring the 'when' field
        """
        # keys_without_when = ['character', 'driver', 'tz', 'where', 'state_specs', 'action_specs', 'reward_specs']
        keys_without_when = list(self.plot_dict.keys()).remove('when')
        return all([self.plot_dict[key] == plot_to_compare[key] for key in keys_without_when])  # type: ignore


class State(TypedDict):
    """State vector of the episode."""

    velocity: List[float]
    thrust: List[float]
    brake: List[float]


class Action(TypedDict):
    """Action of the episode."""

    action: List[float]


class ObservationRecordFlat(TypedDict):
    """Observation (Step) of the episode for RDPG"""

    timestamp: datetime
    observation: List[float]  # flat overlay of state, action, reward, next_state


class ObservationRecordArr(TypedDict):
    """Observation (Step) of the episode for RDPG"""

    timestamp: datetime
    state: List[float]  # flat overlay of state, action, reward, next_state
    action: List[float]
    next_state: List[float]
    action_start_row: int
    reward: float


class ObservationDeep(TypedDict):
    """Observation (Step) of the episode for RDPG"""

    timestamp: datetime
    state: State
    action: Action
    action_start_row: int
    reward: float


class ObservationRecordDeep(ObservationDeep):
    """Observation (Step) of the episode for DDPG."""

    next_state: State


class RecordDoc(TypedDict):
    """Record of the observation"""

    _id: NotRequired[ObjectId]  # for record, _id is generated by pymongo, not required
    timestamp: datetime
    plot: Optional[Plot]
    observation: ObservationRecordDeep


class RecordArr(TypedDict):
    """
    Record of the observation
    using np.ndarray
    """

    episode_starts: datetime
    plot: Optional[Plot]
    timestamps: ndarray
    states: ndarray
    actions: ndarray
    rewards: float
    next_states: ndarray
    table_start_rows: int


class ObservationArr(TypedDict):
    """State, action and reward of the episode"""

    timestamp: datetime
    states: ndarray
    actions: ndarray
    action_start_row: int
    reward: float


class EpisodeDoc(TypedDict):
    """Episode of the record"""

    _id: NotRequired[ObjectId]  # for record, _id is generated by pymongo, not required
    timestamp: datetime  # start of the episode
    plot: Optional[Plot]
    history: list[ObservationDeep]  # length of the list is the length of the episode


class EpisodeArr(TypedDict):
    """Episode of the record"""

    start: datetime
    plot: Optional[Plot]
    history: list[ObservationArr]


# ItemT = TypeVar("ItemT", bound=TypedDict)
ItemT = TypeVar('ItemT', RecordDoc, EpisodeDoc, RecordArr, EpisodeArr)
DocItemT = TypeVar('DocItemT', RecordDoc, EpisodeDoc)
ArrItemT = TypeVar('ArrItemT', RecordArr, EpisodeArr)


def get_filepool_config(
    data_folder: str, config_file: Optional[str], coll_type: str, plot: Plot
) -> ConfigParser:
    """Get the filepool config from the specified path
        data_folder + '\' + config_file
        and compare the meat data with the plot info
    Returns:
        ConfigParser: filepool config
    """

    recipe_p = re.compile(r'^[A-Za-z]\w*\.ini$')
    if config_file is None:
        config_file = 'recipe.ini'
    elif not recipe_p.match(config_file):
        raise ValueError('config_file name is not valid')
    number_states, number_actions = plot.get_number_of_states_actions()
    default_recipe_from_plot: ConfigParser = ConfigParser()
    default_recipe_from_plot.read_dict(
        {
            'DEFAULT': {
                'data_folder': data_folder,  # '.',
                'recipe_file_name': config_file,  # 'recipe.ini',
                'coll_type': coll_type,
                'capacity': '300000',
                'index': '0',
                'full': 'False',  # flag True if the storage is full
            },
            'array_specs': {
                'character': plot.plot_dict['character'],  # vehicle the agent
                'driver': plot.plot_dict['driver'],
                'states': str(number_states),  # 50*4*3
                'actions': str(number_actions),  # 17*4
                'rewards': '1',
                'next_states': str(number_states),  # 50*4*3
                'table_start_rows': '1',
            },
        }
    )

    recipe = ConfigParser()
    try:
        recipe.read(data_folder + '/' + config_file)
        # check if the recipe is matching with the truck specs
        assert (
            recipe['array_specs'] == default_recipe_from_plot['array_specs']
        ), f"ini file array_specs is not matching the realtime truck signal specs"
    except FileNotFoundError:
        recipe = default_recipe_from_plot
    except Exception as e:
        raise e

    return recipe
